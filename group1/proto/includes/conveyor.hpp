#ifndef CONVEYOR_HPP
#define CONVEYOR_HPP

#include "units.hpp"
#include "config.hpp"
#include <algorithm>
#include <chrono>
#include <cstdint>
#include <iostream>
#include <math.h>


class Conveyor
{
public:
    Conveyor() = default;
    void update()
    {
        upm_target = calc_upm(speed_target);
        if (upm_current == upm_target)
            std::cout << "Target and current are same\n";
        else
        {
            auto now = std::chrono::high_resolution_clock::now();
            auto diff = now - shift_begin;
            auto diff_ms = std::chrono::duration_cast<std::chrono::milliseconds>(diff);
            if (diff_ms.count() >= shift_time)
            {
                // Set the start time to be current time for the next check
                shift_begin = now;
                
                // Increase or decrease current upm and speed
                upm_current = update_upm(upm_target, upm_current);
                speed_current = calc_speed(upm_current);
                
                // Increase or decrease current power
                power_current = calc_power(upm_current);

                // Increase or decrease current efficiency
                efficiency_current = calc_efficiency(upm_current);

                // Increase or decrease temperature
                temperature = calc_temperature(power_current, efficiency_current);
            }
        }
        if (!broken && upm_current > speed_breakdown)
        {
            int rand = std::rand() % 100;
            if (rand < breakdown_prob)
                broken = true;
        }
    };

    bool configure(Configuration& config)
    {
        speed target = config.data["Simulation"]["Conveyor"]["speed_target"];
        speed current = config.data["Simulation"]["Conveyor"]["speed_current"];
        if (target >= 0 && target <= 255 && current >= 0 && current <= 255)
        {
            speed_target = static_cast<uint8_t>(target);
            speed_current = static_cast<uint8_t>(current);
            upm_target = calc_upm(speed_target);
            upm_current = calc_upm(current);
            efficiency_current = calc_efficiency(upm_current);
            power_current = calc_power(upm_current);
            temperature = calc_temperature(power_current, efficiency_current);
        }
        else
        {
            std::cout << "Configuration error: Conveyor speeds must be 0-255\n";
            return false;
        }
        return true;
    }

    void set(uint8_t value)
    {
        if (broken)
        {
            speed_target = std::min(static_cast<unsigned>(value),
            static_cast<unsigned>(broken_speed_max));
        }
        else
            speed_target = static_cast<unsigned>(value);
    }
    void set_current(uint8_t value)
    {
        if (value <= 255 && value >= 0)
            speed_current = value;
    }
    uint8_t get()
    {
        return speed_current;
    }
    void overheating()
    {
        /*
        ** Do something fun
        */
    }
    celsius get_temperature()
    {
        return temperature;
    }

private:
    double upm_current {600}; // 0-600 units per minute (conveyor speed)
    double upm_target {0}; // 0-600 units per minute target (conveyor speed)
    uint8_t speed_target {0}; // 0-255 conveyor speed set by controller
    uint8_t speed_current {0}; // 0-255 convoyer speed sent to controller
    milliseconds shift_time {1000}; // Time to shift speed by 1upm
    time_stamp shift_begin = std::chrono::high_resolution_clock::now();
    //const speed upm_min {0}; unused
    //const speed upm_max {600}; unused

    double efficiency_current {56}; // current efficiency (56 - 100)
    watts power_current {20000};  // current power in watts (350 - 20000)
    const watts power_min {350};
    const watts power_max {20'000};
    const double one_upm_in_watts {32.75}; // power per 1 upm
    const double upm_per_speed {600.0 / 255}; // amount of units per second per speed
    const double efficiency_min {100}; // how much power is converted to heat
    const double efficiency_max {56.0}; // how much power is converted to heat
    const double max_efficiency_upm {60}; // upm at which max efficiency is reached
    const watts watts_per_celsius {1000}; // how many watts to increase temperature by 1 celsiud
    double temperature {11.2}; // heat generated by conveyor
    
    const celsius breakdown_temperature {80}; // temp which after breakdown is possible
    const speed speed_breakdown {540}; // upm after which breakdown is possible
    const double breakdown_prob {5}; // probability for breakdonw in %
    bool broken {false};
    uint8_t broken_speed_max {200}; // max speed when broken

    double update_upm(double target, double current)
    {
        if (target > current)
            return ++current;
        return --current;
    }
    double calc_upm(uint8_t speed)
    {
        return std::floor(unsigned(speed) * upm_per_speed);
    }
    uint8_t calc_speed(double upm)
    {
        return std::floor(upm / upm_per_speed);
    }
    double calc_power(double upm_current)
    {
        return power_min + upm_current * one_upm_in_watts;
    }
    double calc_efficiency(double upm)
    {
        return std::max(efficiency_max,
            (efficiency_min -
            ((efficiency_min - efficiency_max) * upm / max_efficiency_upm)));
    }
    double calc_temperature(double power, double efficiency)
    {
        // efficiency / 100 for easier use since it represents percentage
        return power * (efficiency / 100) / watts_per_celsius;
    }
};

#endif
