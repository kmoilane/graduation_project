#ifndef CONVEYOR_HPP
#define CONVEYOR_HPP

#include "units.hpp"
#include <algorithm>
#include <chrono>
#include <cstdint>
#include <iostream>
#include <math.h>


class Conveyor
{
public:
    Conveyor() = default;
    void update_conveyor()
    {
        upm_target = std::floor(unsigned(speed_target) * upm_per_speed);
        if (upm_current == upm_target)
            std::cout << "Target and current are same\n";
        else
        {
            auto now = std::chrono::high_resolution_clock::now();
            auto diff = now - shift_begin;
            auto diff_ms = std::chrono::duration_cast<std::chrono::milliseconds>(diff);
            if (diff_ms.count() >= shift_time)
            {
                // Set the start time to be current time for the next check
                shift_begin = now;
                
                // Increase or decrease current speed
                upm_current = update_speed(upm_target, upm_current);
                
                // Increase or decrease current power
                power_current = update_power(upm_target, upm_current, power_current);

                // Increase or decrease current efficiency
                efficiency_current = update_efficiency(upm_current);

                // Increase or decrease temperature
                temperature = update_temperature(power_current, efficiency_current);
            }
        }
        if (!broken && upm_current > speed_breakdown)
        {
            int rand = std::rand() % 100;
            if (rand < breakdown_prob)
                broken = true;
        }
    };

    void set(uint8_t value)
    {
        if (broken)
        {
            speed_target = std::min(static_cast<unsigned>(value),
            static_cast<unsigned>(broken_speed_max));
        }
        else
            speed_target = static_cast<unsigned>(value);
    }
    void overheating()
    {
        /*
        ** Do something fun
        */
    }
    celsius get_temperature()
    {
        return temperature;
    }

private:
    double upm_current {600}; // 0-600 units per minute (conveyor speed)
    double upm_target {0}; // 0-600 units per minute target (conveyor speed)
    uint8_t speed_target {0}; // 0-255 conveyor speed set by controller
    milliseconds shift_time {1000}; // Time to shift speed by 1upm
    time_stamp shift_begin = std::chrono::high_resolution_clock::now();
    //const speed upm_min {0}; unused
    //const speed upm_max {600}; unused

    double efficiency_current {56}; // current efficiency (56 - 100)
    watts power_current {20000};  // current power in watts (350 - 20000)
    const watts power_min {350};
    const watts power_max {20'000};
    const double one_upm_in_watts {32.75}; // power per 1 upm
    const double upm_per_speed {600.0 / 255}; // amount of units per second per speed
    const double efficiency_min {100}; // how much power is converted to heat
    const double efficiency_max {56.0}; // how much power is converted to heat
    const double max_efficiency_upm {60}; // upm at which max efficiency is reached
    const watts watts_per_celsius {1000}; // how many watts to increase temperature by 1 celsiud
    double temperature {11.2}; // heat generated by conveyor
    
    const celsius breakdown_temperature {80}; // temp which after breakdown is possible
    const speed speed_breakdown {540}; // upm after which breakdown is possible
    const double breakdown_prob {5}; // probability for breakdonw in %
    bool broken {false};
    speed broken_speed_max {200}; // max speed when broken

    double update_speed(double target, double current)
    {
        if (target > current)
            return ++current;
        return --current;
    }
    double update_power(double upm_target, double upm_current, watts curr)
    {
        if (upm_target > upm_current)
            return curr += one_upm_in_watts;
        return curr -= one_upm_in_watts;
    }
    double update_efficiency(double upm)
    {
        return std::max(efficiency_max,
            (efficiency_min -
            ((efficiency_min - efficiency_max) * upm / max_efficiency_upm)));
    }
    double update_temperature(double power, double efficiency)
    {
        // efficiency / 100 for easier use since it represents percentage
        return power * (efficiency / 100) / watts_per_celsius;
    }
};

#endif
